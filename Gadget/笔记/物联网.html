<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>物联网</title></head>
<body><h1>一、模块</h1>
<h2>1.LED</h2>
<blockquote><h3>贴片：				LED5 →PC15控制，低电平亮</h3>
<h3>继电器控制：    K1-LED→PA0控制，高电平亮</h3>
<h3>继电器控制：    K2-LED→PA1控制，高电平亮</h3>
</blockquote>
<h2>2.USER摁键</h2>
<blockquote><h3>由PC14控制，摁下为0，平时为1(应配为上拉)</h3>
</blockquote>
<h3>长摁与短摁的实现：</h3>
<pre><code class='language-c' lang='c'>unsigned int KEY_flag=0;
uint16_t count=0;

void Key_scan()		//直接将扫描函数丢到定时器里
{
	if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_14)==0)			//摁键摁下
	{
		count++;
	}
	if(HAL_GPIO_ReadPin(GPIOC,GPIO_PIN_14)==1)			//摁键松开
	{
		if(count&gt;1&amp;&amp;count&lt;100)	//利用定时器判断摁下时间
		{
			KEY_flag=1;
		}	
		if(count&gt;=100)		//按下经过1s  10*100ms=1s
		{
			KEY_flag=2;
		}
		count=0;
	}
}
void Led_scan()
{
	if(KEY_flag==1)
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_RESET);
	}
	if(KEY_flag==2)
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_SET);
	}
}
</code></pre>
<h2>3.显示屏OLED</h2>
<blockquote><h4>打开参考文件已有初始化函数 void Task_BrdInit(void);将其放在BEGIN与END之间，再配置CubeMX，就不会因为重新生成工程而不见了。</h4>
<h4>用到最多的无非两个函数sprintf()、OLED_ShowString()；啥都ok</h4>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220214175232026.png" referrerpolicy="no-referrer" alt="image-20220214175232026"></p>
</blockquote>
<h3>①.解决显示屏不清位问题（7位变5位多两位不清除）</h3>
<pre><code class='language-c' lang='c'>void OLED_ShowString(uint8_t x, uint8_t y, uint8_t *chr, uint8_t Char_Size)
{										//由函数初始值可知，字符串第一位显示的位置x,也可计算出字符串的长度
    unsigned char j = 0,x1;
	x1=x;								//保存字符串第一位显示的位置x
    while (chr[j] != &#39;\0&#39;)
    {
        OLED_ShowChar(x, y, chr[j], Char_Size);
        x += 8;
        if(x &gt; 120)
        {
            x = 0;
            y += 2;
        }
        j++;
    }
    for(j=0;j&lt;x1;j=j+8)				//从第0位到第一位显示的位置x，都用空格显示
    {													//细节：每8位为一个字节的宽度
        OLED_ShowChar(j, y, &#39; &#39;, Char_Size);
    }
    for(j=x;j&lt;128;j=j+8)			//从字符串最后一位的位置到显示屏能显示的最长位置128，都用空格显示
    {
        OLED_ShowChar(j, y, &#39; &#39;, Char_Size);
    }
}
</code></pre>
<h3>②.OLED屏显示占用系统教程，影响其他模块灵敏度（比如摁键不灵敏）</h3>
<pre><code class='language-c' lang='c'>if(time_100ms==1)		//使用定时器产生100ms，每隔100ms启动一次显示屏，对其他程序就不会造成影响
{
    OLED_ShowString(0, 0, (unsigned char *)lcdLine_1st_line, 16);
    OLED_ShowString(0, 2, (unsigned char *)lcdLine_2st_line, 16);
    time_100ms=0;		//执行一次之后另定时器重新计时
}
</code></pre>
<h2>4.矩阵摁键</h2>
<blockquote><h4>行：PB6（上）、PB7（下）——这两引脚用来输入</h4>
<h4>列：PB1（左）、PB0（中）、PA8（右）</h4>
<h5>其中PA8引脚与显示屏的时钟scl引脚撞了</h5>
<h4>注意的点：</h4>
<h4>①GPIO的引脚配置：GPIO_InitStruct.Pull = GPIO_PULLDOWN;{GPIO_ULLUP(上拉)、GPIO_ULLDOWN（下拉）、GPIO_NOPULL（既不上拉也不下拉），这几个参数指的是引脚无操作时保持的状态，上拉高电平，下拉低电平。<mark>必须结合摁键扫描来配置</mark>}</h4>
<h4>②部分代码：三处小细节</h4>
<pre><code class='language-c' lang='c'>unsigned int KEY_flag;	//该函数为摁键标志位，须使用extern宏定义

void key_scan()			//此函数利用定时器10ms消抖，不再使用额外消抖
{
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6))
		KEY_flag=11;
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7))
		KEY_flag=21;

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6))
		KEY_flag=12;
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7))
		KEY_flag=22;

	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_6))
		KEY_flag=13;
	if(HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_7))
		KEY_flag=23;
}

void Led_scan()			//执行函数，什么摁键执行命令
{
	if(KEY_flag==11)
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_SET);
	}
	if(KEY_flag==21)
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_RESET);
	}
}

----------------------------------------------------------------------------------------------------
main函数里的调用：
 if(time_10ms==1)	//此处用定时器定时10ms
     key_scan();
	Led_scan();
</code></pre>
</blockquote>
<blockquote><h4>③如果没用到B3,B6键，就别开，会有延时影响。</h4>
</blockquote>
<h2>5.ADC</h2>
<blockquote><p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220214180429857.png" referrerpolicy="no-referrer" alt="image-20220214180429857"></p>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220222182649799.png" referrerpolicy="no-referrer" alt="image-20220222182649799"></p>
<h3>注意：配置完初始状态，要将ADC中断打开（ADC也有中断！）</h3>
<h2>用到无非三个函数：</h2>
<pre><code class='language-c' lang='c'>for(i=0;i&lt;=1;i++)
{
	HAL_ADC_Start(&amp;hadc);		//启动ADC
	HAL_ADC_PollForConversion(&amp;hadc,100);	//等待转换完成，延时时间100ms
	ad[i]=HAL_ADC_GetValue(&amp;hadc)*(3.3/4095);	//获取AD数值（0-4095），需要转为电压值。
}	//获取一个通道AD值，再次循环可获得第二个通道
</code></pre>
</blockquote>
<h2>6.温度传感器</h2>
<blockquote><p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220214180540002.png" referrerpolicy="no-referrer" alt="image-20220214180540002"></p>
</blockquote>
<h2>7.RTC时钟</h2>
<blockquote><h3>在STM32CubeMX中找到RCT,</h3>
<h3>勾选两项：Activate Clock Source（激活时钟）、Activate Calendar（激活日历）</h3>
<h3>设置同步预分频——307</h3>
<h3>使用十进制</h3>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220222191155901.png" referrerpolicy="no-referrer" alt="image-20220222191155901"></p>
</blockquote>
<h2>8.外部中断</h2>
<blockquote><h3>只需在<mark>stm32l0xx_it.c</mark>文件中找到<mark>HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10)</mark>中断函数并进入其定义，即可找到回调函数<mark>HAL_GPIO_EXTI_Callback(GPIO_Pin)</mark></h3>
</blockquote>
<pre><code class='language-c' lang='c'>void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)	//中断回调函数
{
	if(GPIO_Pin==GPIO_PIN_10)	//判断中断是哪个引脚产生的，严谨性
	{
		;
	}
}
</code></pre>
<h2>9.定时器中断</h2>
<h3>1.普通定时器（TIM6,TIM7）</h3>
<h4>①配置</h4>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220315222302950.png" referrerpolicy="no-referrer" alt="image-20220315222302950"></p>
<blockquote><h4>定时器的计算公式：T=（arr+1）*（psc+1）/CLK。其中，CLK是MCU的时钟频率，arr和psc分别为自动重装载值和预分频系数。</h4>
<h4>比如定时1毫秒，假设时钟频率为32MHZ，只需要设定arr和psc分别为999和31就可以了。计算如下：1ms=（31+1）*（999+1）/32MHZ。值得注意的是，arr和psc分别为31和999也可以</h4>
</blockquote>
<h4>②代码</h4>
<blockquote><h4>只用到两个函数即可HAL_TIM_Base_Start_IT(&amp;htim6) 与 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</h4>
<h4><mark>HAL_TIM_Base_Start_IT(&amp;htim6) 函数</mark>：放在while循环前即可使能定时器</h4>
<h4>在stm32l0xx_hal_tim.c文件里，搜索<mark>start</mark>即可找到该函数</h4>
<h4><mark>HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)函数</mark>：定时器回调函数，放在main函数外</h4>
<h4>在stm32l0xx_hal_tim.c文件里，搜索<mark>__weak</mark>即可找到该函数(多找几下就有了)</h4>
</blockquote>
<h3>2.通用定时器（TIM2,TIM3），一般只用来输出PWM</h3>
<h4>①配置</h4>
<p><img src="D:\Software\Data\Desktop\QQ截图20220329194902.png" referrerpolicy="no-referrer" alt="QQ截图20220329194902"></p>
<h4>②代码</h4>
<blockquote><h4>只用到两个函数即可HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3)	与	__HAL_TIM_SET_COMPARE(&amp;htim2,TIM_CHANNEL_2,500);</h4>
<h4><mark>HAL_TIM_PWM_Start(&amp;htim3, TIM_CHANNEL_3)函数</mark>：放在while函数之前即可使能PWM</h4>
<h4>在stm32l0xx_hal_tim.c文件里，搜索<mark>PWM</mark>即可找到该函数</h4>
<h4><mark>__HAL_TIM_SET_COMPARE(&amp;htim2,TIM_CHANNEL_3,500)函数</mark>：用做比较PWM输出，其中500与重装载值999的比值，就是输出PWM的占空比</h4>
<h4>在stm32l0xx_hal_tim.c文件里，搜索<mark>compare</mark>即可找到该函数</h4>
</blockquote>
<h2>10.串口</h2>
<blockquote><h3>①因为存在系统CPU占用过多，所以直接使用<mark>DMA传输</mark>（既可以省系统时间，也可以忽略数据量过大）</h3>
<h3>②一般使用<mark>空闲中断</mark>接收数据（既可以确定长度也可以不定长度数据）</h3>
<h3>③DMA配置细节，一般只配置输入单片机（rx）的DMA，不配置输出（tx）。因为DMA不能同时双向传输，本身串口也不是全双工。</h3>
</blockquote>
<pre><code class='language-c' lang='c'>//	main函数里的初始化
__HAL_UART_CLEAR_IDLEFLAG(&amp;huart2);	
__HAL_UART_ENABLE_IT(&amp;huart2, UART_IT_IDLE);
HAL_UART_Receive_DMA(&amp;huart2,reply,50);

void rx2(void)		//需将rx2()放在void USART2_IRQHandler(void)串口中断函数里
{
	if(RESET != __HAL_UART_GET_FLAG(&amp;huart2, UART_FLAG_IDLE))   //判断是否是空闲中断
	{
		__HAL_UART_CLEAR_IDLEFLAG(&amp;huart2); 		//清除空闲中断标志（否则会一直不断进入中断）
		HAL_UART_DMAStop(&amp;huart2);   
        uart_flag=1;		//设置串口已接收的标志位
   		HAL_UART_Receive_DMA(&amp;huart2,reply,50);		//重启开始DMA传输 每次255字节数据
	}
}
</code></pre>
<h2>11.CRC校验</h2>
<blockquote><p>找到CRC，勾选，keil里调用函数使用就行了。</p>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220214174928266.png" referrerpolicy="no-referrer" alt="image-20220214174928266"></p>
</blockquote>
<h2>常用函数</h2>
<h3>①对变量进行处理</h3>
<h4>sprintf()函数：数字变字符串</h4>
<blockquote><p>char lcdLine_1st_line[16];</p>
<p><mark>sprintf(lcdLine_1st_line, &quot;%f&quot;,tem);</mark></p>
<p>tem为数字，sprintf（）的作用为把数字<mark>转为char类型</mark>的字符串</p>
</blockquote>
<h4>sscanf()函数：字符串变数字</h4>
<blockquote><p>①	sscanf(  (char *)rx,&quot;%d-%d-%d&quot;,&amp;h,&amp;m,&amp;s);	//将字符串转数字</p>
<p>②	sscanf(&quot;654321abcdedfABCDEF&quot;, &quot;%[1-9a-z]&quot;, str); 	//取仅包含指定字符集的字符串
  		printf(&quot;str=%s\n&quot;, str);  	//str=654321abcded，只取数字和小写字符</p>
<p>③	sscanf(&quot;zhoue3456 &quot;, &quot;%4s&quot;, str); 	//取指定长度的字符串 <br/>  		printf(&quot;str=%s\n&quot;, str); 	//str=&quot;zhou&quot;;</p>
<p>④	sscanf(&quot;BCDEF123456abcdedf&quot;, &quot;%[ ^ a-z]&quot;, str); 	//取到指定字符集为止的字符串  <br/>   		printf(&quot;str=%s\n&quot;, str);  	//  str=BCDEF123456, 取遇到大写字母为止的字符串</p>
</blockquote>
<h4>strlen()函数：测量字符串实际长度（不包含‘\0’）</h4>
<blockquote><p>char b[]=&quot;love&quot;;</p>
<p>printf(&quot;%ld\n&quot;,strlen(b));	//结果为4</p>
</blockquote>
<h4>strcat（）函数：字符串拼接</h4>
<blockquote><p>adc=strcat(lcdLine_1st_line,&quot;   &quot;); 
adc=strcat(adc,lcdLine_2st_line); </p>
</blockquote>
<h4>sizeof()函数：测量字符串字节大小——所占内存（一般用不到）</h4>
<blockquote><p>unsigned int lon;</p>
<p>char lcdLine_1st_line[16];</p>
<p>lon=sizeof(lcdLine_1st_line);</p>
<p>sizeof()的作用是测量字符串包含的字符个数。</p>
</blockquote>
<h3>②位运算</h3>
<figure><table>
<thead>
<tr><th>a</th><th>b</th><th style='text-align:center;' >a&amp;b（且）</th><th style='text-align:center;' >a|b（或）</th><th style='text-align:center;' >a^b（异或）</th><th style='text-align:center;' >~a（位反）</th><th style='text-align:center;' >!a（值反）</th></tr></thead>
<tbody><tr><td>0</td><td>0</td><td style='text-align:center;' >0</td><td style='text-align:center;' >0</td><td style='text-align:center;' >0</td><td style='text-align:center;' >1</td><td style='text-align:center;' >0</td></tr><tr><td>0</td><td>1</td><td style='text-align:center;' >0</td><td style='text-align:center;' >1</td><td style='text-align:center;' >1</td><td style='text-align:center;' >1</td><td style='text-align:center;' >0</td></tr><tr><td>1</td><td>0</td><td style='text-align:center;' >0</td><td style='text-align:center;' >1</td><td style='text-align:center;' >1</td><td style='text-align:center;' >0</td><td style='text-align:center;' >0</td></tr><tr><td>1</td><td>1</td><td style='text-align:center;' >1</td><td style='text-align:center;' >1</td><td style='text-align:center;' >0</td><td style='text-align:center;' >0</td><td style='text-align:center;' >0</td></tr></tbody>
</table></figure>
<h1>二、用到的.c文件</h1>
<h2>·stm32l0xx_hal_<mark>gpio</mark>.c</h2>
<blockquote><h3>①	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_15, GPIO_PIN_RESET);</h3>
<h3>②	HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_15);</h3>
<h3>③	HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_15);</h3>
<h3>④	__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin);	//中断时用到，其为弱函数，直接拿过来当作自己的函数。在{}里写上中断时需要执行的命令。例如：</h3>
<pre><code class='language-c' lang='c'>void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
}
</code></pre>
</blockquote>
<h2>·oled.c</h2>
<blockquote><h3>OLED_Clear();	//功能函数，清屏</h3>
<h3>OLED_ShowChar(0, 2, (unsigned char *)                 rx , 16);</h3>
<h3>OLED_ShowString(0, 0, (unsigned char *)&quot;                &quot;, 16);</h3>
</blockquote>
<h2>· stm32l0xx_<mark>hal</mark>.c</h2>
<blockquote><h3>HAL_Delay(1);	//1ms</h3>
</blockquote>
<h2>·stm32l0xx_hal_<mark>cortex</mark>.c</h2>
<blockquote><h3>HAL_NVIC_SystemReset(void);	//功能函数，使系统复位，重新执行mai()函数。（总结：软件复位就是一个函数的事情）</h3>
</blockquote>
<h2>·stm32l0xx_hal_<mark>crc</mark>.c</h2>
<blockquote><p>只用到一个函数HAL_CRC_Calculate();将一个数组计算为CRC校验码</p>
<p>unsigned int 	Data_Buffer[10] = {0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006,
                         0x00000007, 0x00000008, 0x00000009, 0x0000000A};
unsigned int 	CRC_Value = HAL_CRC_Calculate(&amp;hcrc, Data_Buffer, 10);</p>
</blockquote>
<h2>·stm32l0xx_hal_<mark>rtc</mark>.c</h2>
<blockquote><p>用的无非一个结构体和两个函数</p>
<p>(小细节：最好固定显示位数，没有用0补，否则可能出现有的数字没消掉)</p>
<p>RTC_TimeTypeDef time;
RTC_DateTypeDef data;	//这两个函数用来定义结构体，须用extern构成全局变量，方便更改时间。（可参考已给出的RTC_HandleTypeDef hrtc;以此来设置全局变量）</p>
<p>&nbsp;</p>
<p>data.Year= 22;	//以这种方式设置日期
data.Month=2;
data.Date=14;
	HAL_RTC_SetDate(&amp;hrtc, &amp;NowDate, RTC_FORMAT_BIN);	//以上配置好日期就用设置函数确认(BIN为十进制，BCD为16进制)
time.Hours=10;	//以这种方式设置时间
time.Minutes=03;
time.Seconds=59;
	HAL_RTC_SetDate(&amp;hrtc,&amp;data,RTC_FORMAT_BIN);	//以上配置好时间就用设置函数确认</p>
<p>&nbsp;</p>
<p>HAL_RTC_GetTime(&amp;hrtc,&amp;time,RTC_FORMAT_BIN);	//获取时间（<mark>须先获取时间再获取日期</mark>，顺序不能错，不然会出错）
HAL_RTC_GetDate(&amp;hrtc,&amp;data,RTC_FORMAT_BIN);	//只是功能函数，调用时间就会存在变量里面，不需要返回值
sprintf(lcdLine_1st_line, &quot;%d : %d : %d &quot;, data.Year, data.Month, data.Date);
sprintf(lcdLine_2st_line, &quot;%d : %d : %d &quot;, time.Hours, time.Minutes, time.Seconds);</p>
</blockquote>
<h2>·stm32l0xx_hal_<mark>adc</mark>.c</h2>
<blockquote><p>HAL_ADC_Start(&amp;hadc);		在stm32l0xx_hal_adc.h 搜索关键字<mark>start</mark></p>
<p>HAL_ADC_PollForConversion(&amp;hadc,100);</p>
<p>ad[i]=HAL_ADC_GetValue(&amp;hadc)*(3.3/4095);	在stm32l0xx_hal_adc.h 搜索关键字<mark>get</mark></p>
</blockquote>
<h2>·sx127x_lora.c</h2>
<h2>·I2C.c</h2>
<blockquote><h3>打开参考文件HAL_OLED时，立马已包括这个.c文件，无需更改无需操作。</h3>
<h3>但用到温度模块时，须依据这个.c文件重新写一个适用于温度模块的i2c通信协议。</h3>
</blockquote>
<h2>· spi.c	与	zm4xx_gpio.c</h2>
<blockquote><h3>用于板子之间的通信，只须调进工程里，其他可以从参考文件搬运</h3>
</blockquote>
<p>&nbsp;</p>
<h1>三、细节处理</h1>
<h2>1.定时器使用细节</h2>
<h3>①定时器中断回调函数，其内部最好最好尽量<mark>只用标志位</mark></h3>
<pre><code class='language-c' lang='c'>if(htim-&gt;Instance==TIM6)
{
    time_i++;
    if(time_i==9999)		time_i=0;
    if(time_i%10==0)		time_10ms=!time_10ms;
}
</code></pre>
<h3>②无须手动操作的工作，放在main函数里调用定时器标志位——例如<mark>显示屏、ADC</mark></h3>
<pre><code class='language-c' lang='c'>if(time_100ms==1)
{
    for(i=0;i&lt;=1;i++)
    {
        HAL_ADC_Start(&amp;hadc);
        HAL_ADC_PollForConversion(&amp;hadc,100);
        value[i]=HAL_ADC_GetValue(&amp;hadc)*3.3/4095;
    }
    OLED_ShowString(0, 0, (unsigned char *)lcdLine_1st_line, 16);
    OLED_ShowString(0, 2, (unsigned char *)lcdLine_2st_line, 16);
}
</code></pre>
<h3>③利用定时器消抖的按键，<mark>扫描函数</mark>须放在定时器中断回调函数里,<mark>按键执行函数</mark>放在main</h3>
<pre><code class='language-c' lang='c'> if(htim-&gt;Instance==TIM6)
 {
     time_i++;
     if(time_i==9999)	time_i=0;
     if(time_i%10==0)	
     	key_scan();	
 }
</code></pre>
<h2>2.定时器时间管理</h2>
<h3>①每隔n秒工作n秒</h3>
<blockquote><h3>定义全局标志位，定时器里用 <mark>！</mark> 取反，得到0和1的标志位 ，main函数里判断标志位每到1时执行</h3>
</blockquote>
<h3>②每隔n秒工作一次</h3>
<p>&nbsp;</p>
<h3>③只工作n秒</h3>
<blockquote><h3>定义全局标志位flag，定时器用 <mark>++</mark> 累加得到工作时间。main函数里触发工作时，使标志位为0，定时器后台自动累加，main函数再判断标志位flag&gt;n，就停止工作</h3>
<pre><code class='language-c' lang='c'>//---------------------------↓↓main函数
flag=0;
if(flag&gt;20)		//工作2秒
{
 sprintf(lcdLine_1st_line, &quot;REC:None&quot;);
 sprintf(lcdLine_2st_line, &quot;ADC:None&quot;);
}
//---------------------------↓↓定时器
if(htim-&gt;Instance==TIM6)
{
 time_i++;
 if(time_i==9999)		time_i=0;
 if(time_i%100==0)		
 {
     flag++;
 }
}
</code></pre>
</blockquote>
<p>&nbsp;</p>
<h1>四、问题</h1>
<h2>1.无法烧入（能识别驱动，但是就是不能烧入）</h2>
<blockquote><p>长摁复位键，同时点烧入。这时会出现keil报错，关闭所有错误再烧入，便能烧入程序</p>
</blockquote>
<h2>2.USER摁键</h2>
<blockquote><p>闲置为高电平，摁下为低电平</p>
</blockquote>
<h2>3.在中断里无法使用HAL_Delay()函数，达不到预期效果</h2>
<blockquote><p>因为HAL_Delay()函数不能同时使用，会存在优先级错乱</p>
</blockquote>
<h2>4.STM32CubeMX重新配置，生成的工程会把之前的代码删掉</h2>
<blockquote><p>/* USER CODE BEGIN xxxx */</p>
<p>            可以在此处BEGIN、END之间放代码，就不会被重置</p>
<p>/* USER CODE END  xxxx*/</p>
</blockquote>
<h2>5.HAL_Delay()的使用（但是不用，定时器比较香）</h2>
<h3>做摁键消抖时，24MHZ时钟时，用20的延迟。32MHZ时钟时，用50的延迟。</h3>
<h2>6.hal库里的__weak ...()函数</h2>
<blockquote><p>__weak 表示弱函数，可以被重写</p>
</blockquote>
<p>&nbsp;</p>
<h1>创建项目细节</h1>
<h2>1.移、改、增</h2>
<blockquote><h3>①把官方文件HAL_OLED拷贝当作自己的工程，打开项目<mark>将void Task_BrdInit(void)移到begin、end的之间</mark>（避免配置工程被删）</h3>
<h3>②将官方文件LoRa_STM32L0_API移动至自己工程，然后添加.h文件的路径，并勾选复位按钮</h3>
<p><img src="C:\Users\007\AppData\Roaming\Typora\typora-user-images\image-20220210165806988.png" referrerpolicy="no-referrer" alt="image-20220210165806988"></p>
<h2>③将官方文件LoRa_HAL\LoRa_P2P\Node-A里的.c文件驱动代码放到自己的工程里，并<mark>增加OLED的占位显示优化</mark></h2>
</blockquote>
<h2>2.配置</h2>
<blockquote><h3>①SYS								  ------一次</h3>
<h3>②串口		</h3>
<h3>③CRC								-----两次</h3>
<h3>④DMA</h3>
<h3>⑤PA10</h3>
<h3>⑥RTC</h3>
<h3>⑦定时器</h3>
<h3>⑧NVIC中断使能		----三次</h3>
<h3>⑨时钟（32MHZ）</h3>
<h3>⑩项目分类.c、.h</h3>
<h3>⑾其他外设</h3>
<h5>规律——从上到下三次</h5>
</blockquote>
<h2>3.必备初始化代码</h2>
<blockquote><h3>①定时器初始化</h3>
<h3>②LoRa中断配置</h3>
</blockquote>
<h2>4.有备无患环节</h2>
<blockquote><p>复制以上准备好的工程<mark>两份</mark></p>
</blockquote>
<h1>资料搜索</h1>
<h2>1.物联网资源</h2>
<h3>网页</h3>
<blockquote><p><a href='https://blog.csdn.net/qq_37215047/category_10739754.html' target='_blank' class='url'>https://blog.csdn.net/qq_37215047/category_10739754.html</a></p>
</blockquote>
<h3>公众号:</h3>
<blockquote><p>撞上电子</p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>		</p>
</body>
</html>